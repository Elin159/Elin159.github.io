<!-- 博文的布局-Layout -->
<!DOCTYPE html>
<html>
<head>
<!-- 引入head标签 -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-sclable=0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="description" content="华南仔的学习笔记" />
<meta name="keywords" content="your web keywords, another keywords" />
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="stylesheet" href="/assets/css/media.css">
<link rel="stylesheet" href="/assets/css/animate.min.css">
<link rel="stylesheet" href="/assets/css/pygments/pygments_default.css">
<link rel="stylesheet" href="/assets/css/github-markdown.css">
<!-- SNS-icon -->
<script src="//at.alicdn.com/t/font_856428_y9z6nq7zf5.js"></script>
<!-- share.css -->
<link rel="stylesheet" href="/assets/css/share.min.css">
<!-- font -->
<link rel="stylesheet" href="/assets/css/font.css">
<!-- <link href="https://fonts.googleapis.com/css?family=Kaushan+Script|Pacifico|Ubuntu|Roboto+Mono|Source+Sans+Pro" rel="stylesheet"> -->

<!-- Favicon -->
<!-- <link href="/assets/profile.jpeg" rel="shortcut icon" />
<link href="/assets/profile.jpeg" rel="apple-touch-icon-precomposed" /> -->
<link href="/assets/author.jpeg" rel="shortcut icon" />
<link href="/assets/author.jpeg" rel="apple-touch-icon-precomposed" />
<!-- Android Lolipop Theme Color -->
<!-- <meta name="theme-color" content="#1464FB"> -->
<title>React 基础</title>
<!-- 百度统计 -->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

<!-- 谷歌分析 -->


<!-- Android Lolipop Theme Color -->
<meta name="theme-color" content=" rgb(125,92,31) ">
</head>
<body>

<!-- 顶部锚点 -->
<a id="htmlup" name="htmlup"></a>
<!-- 引入博文顶部选项 -->

<header id="post-header" style="background-color:rgb(125,92,31);">
  <div class="top-center">
      <div class="logo">
          <a href="/" title="my awesome webtitle" style="color: white;">林校长</a>
      </div>
      <nav class="top-nav">
          <ul>
              
                <li><a href="/" style="color: white;">首页</a></li>
              
                <li><a href="/tags.html" style="color: white;">标签</a></li>
              
                <li><a href="/timeline.html" style="color: white;">时间线</a></li>
              
                <li><a href="/about.html" style="color: white;">关于博主</a></li>
              
                <li><a href="/friendLink.html" style="color: white;">友情链接</a></li>
              
          </ul>
      </nav>
      <div id="top-boot">
        <a href="javascript:;" id="boot1" style="display:block;" onclick="document.getElementById('boot-area').style.display='block';document.getElementById('boot1').style.display='none';document.getElementById('boot2').style.display='block';"><img src="/assets/boot_white.png" alt=""></a>
        <a href="javascript:;" id="boot2" style="display: none;" onclick="document.getElementById('boot-area').style.display='none';document.getElementById('boot1').style.display='block';document.getElementById('boot2').style.display='none';"><img src="/assets/boot_white.png" alt=""></a>
      </div>
  </div>

</header>


<!-- 引入移动下拉选项 -->
<div id="boot-area">
    <ul>
        
          <a href="/"><li>首页</li></a>
        
          <a href="/tags.html"><li>标签</li></a>
        
          <a href="/timeline.html"><li>时间线</li></a>
        
          <a href="/about.html"><li>关于博主</li></a>
        
          <a href="/friendLink.html"><li>友情链接</li></a>
        
    </ul>
</div>

<!-- 引入博文顶部样式 -->
<!-- 版本一 垃圾 -->
<!-- <div class="wow fadeIn top" data-wow-duration="3.5s" >
    <span class="wow fadeInUp" data-wow-delay="0.2s">React 基础</span>
    <span class="wow fadeInUp" data-wow-delay="0.4s"></span>
    <span class="wow fadeInUp" data-wow-delay="0.4s"></span>
    <span class="wow fadeInUp" data-wow-delay="0.6s">作者&nbsp;&nbsp;|&nbsp;&nbsp;Elin159</span>
</div> -->

<!-- 版本二 可切换页面 -->

<div class="post-top" style="background-color:rgb(125,92,31);">
  <!-- 页面宽度大于800px -->
  <div class="left-area">
    
      <a href="javascript:;" class="btn bounceInLeft animated" onmouseover="showLeft();this.style.color='rgb(125,92,31)';" onmouseout="goneLeft();this.style.color='rgba(0,0,0,.2)';"><</a>
      <div id="left-tab" style="display:none;"><span class="left-san"></span><span class="left-main" style="color:rgb(125,92,31);"><sapn class="main">没有上一页咯</sapn></span></div>
    
  </div>
  <div class="post-titlearea">
    <span class="wow fadeInUp" data-wow-delay="0.2s">React 基础</span>
    <!-- <span class="wow fadeInUp" data-wow-delay="0.4s"></span> -->
    <!-- <span class="wow fadeInUp" data-wow-delay="0.4s"></span> -->
    <!-- <span class="wow fadeInUp" data-wow-delay="0.6s">作者&nbsp;&nbsp;|&nbsp;&nbsp;Elin159</span> -->
  </div>
  <div class="right-area">
    
      <a href="/2019/08/12/%E7%AC%AC%E5%8D%81%E5%85%AD%E5%A4%A9%E5%AD%A6%E4%B9%A0(React%E5%85%A5%E9%97%A8%E4%B8%80).html" class="btn bounceInRight self-animated" onmouseover="showRight();this.style.color='rgb(125,92,31)';" onmouseout="goneRight();this.style.color='rgba(0,0,0,.2)';">></a>
      <div id="right-tab" style="display:none;"><span class="right-san"></span><span class="right-main" style="color:rgb(125,92,31);"><sapn class="main">React 简介</sapn></span></div>
    
  </div>

  <!-- 页面宽度小于800px -->
  <div class="post-changearea">
    
      <a href="javascript:;" class="leftchange" style="border-right: 1px solid rgb(125,92,31);border-bottom: 2px solid rgb(125,92,31);"><span><br>没有上一篇咯</span></a>
    
    
      <a href="/2019/08/12/%E7%AC%AC%E5%8D%81%E5%85%AD%E5%A4%A9%E5%AD%A6%E4%B9%A0(React%E5%85%A5%E9%97%A8%E4%B8%80).html" class="rightchange" style="border-left: 1px solid rgb(125,92,31);border-bottom: 2px solid rgb(125,92,31);"><span>下一篇<br><br>React 简介</span></a>
    
  </div>
</div>


<div class="markdown-body fadeInUp animated">

  

  <!-- 文章内容 -->
  <h1 id="第17天学习react">第17天学习(React)</h1>

<h1 id="react基础">React基础</h1>

<p>本章将指导你了解React的基础知识。由于静态组件会有些枯燥，所以这章的内容会包含组件的状态于交互。此外，我们将学习使用不同方式声明组件以及如何保持组件的可组合型和可复用性。准备好创造我们自己的组件吧。</p>

<h2 id="组件内容状态">组件内容状态</h2>

<p>组件内部状态也被称为局部状态，允许我们保存、修改和删除存储在组件内部的属性。使用ES6类组件可以在构造函数中初始化组件的状态。构造函数只会在组件初始化时调用一次。</p>

<p>让我们引入类构造函数吧～；</p>

<p>举个小🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="p">...</span>
  
<span class="p">}</span>
</code></pre></div></div>

<p>当我们使用ES6编写的组件有一个构造函数时，它需要强制调用super();方法，因为这个App组件是Component的子类。因此在我们的App组件要声明extends Component。</p>

<p>我们也可以调用super(props); 它会在我们的构造函数中设置this.props 以供在构造函数中访问它们。</p>

<p>否则当在构造函数中访问this.props,会得到undefined。</p>

<p>举个小🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span>
    <span class="na">title</span><span class="p">:</span><span class="s1">'React'</span><span class="p">,</span>
    <span class="na">url</span><span class="p">:</span><span class="s1">'https://facebook.github.io/react/'</span><span class="p">,</span>
    <span class="na">author</span><span class="p">:</span><span class="s1">'Jordan Walke'</span><span class="p">,</span>
    <span class="na">num_comments</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span>
    <span class="na">points</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
    <span class="na">objectID</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">...</span>
<span class="p">];</span>
  
	<span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  	<span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
      
      <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">list</span><span class="p">:</span><span class="nx">list</span><span class="p">,</span>
      <span class="p">}</span>
    <span class="p">}</span>
		<span class="p">...</span>
  <span class="p">}</span>  
  
</code></pre></div></div>

<p>state通过使用this绑定在类上。</p>

<p>因此，我们可以在整个组件中访问到state。例如它可以用在render() 方法中。此前我们已经在render()方法中映射一个在组件外定义静态列表。现在我们可以在组件中使用state里的list了。</p>

<p>举一个中等🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
        <span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">}</span><span class="o">&gt;</span>
          	<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>
            	<span class="p">&lt;</span><span class="nt">a</span> <span class="na">href=</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">url</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">title</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">author</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">num_comments</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">points</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="err">/</span><span class="nt">div</span><span class="p">&gt;</span>
        })<span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在list是组件的一部分。它驻留在组件的state中。</p>

<p>我们可以从list中添加、修改或者删除列表项。</p>

<p>每次我们修改组件的内部状态，组件的render方法会再次运行。</p>

<p>这样我们就可以简单地修改组件内部状态，确保组件重新渲染并且展示从内部状态获取到的正确数据。</p>

<p>⚠️注意：不要直接<strong>修改state</strong>。我们必须使用<strong>setState()</strong>方法来修改它。</p>

<h2 id="es6对象初始化">ES6对象初始化</h2>

<p>在ES6中，我们可以通过简写属性更加简洁地初始化对象。</p>

<p>举个小🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">'Robin'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span><span class="nx">name</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>当我们的对象中的属性名与变量名相同时，我们可以执行以下的操作：</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">'Robin'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">name</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>在应用程序中，我们也可以这样做。列表变量名和状态属性名称共享同一名称。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ES5</span>
<span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">list</span><span class="p">:</span> <span class="nx">list</span><span class="p">,</span>
<span class="p">};</span>
<span class="c1">//ES6</span>
<span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">list</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>另一个简洁的辅助办法是<strong>简写方法名</strong>。</p>

<p>举个🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ES5</span>
<span class="kd">var</span> <span class="nx">userService</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">getUserName</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="nx">user</span><span class="p">.</span><span class="nx">lastname</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">}</span>
<span class="c1">//ES6</span>
<span class="kd">const</span> <span class="nx">userService</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">getUserName</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">firstname</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="nx">user</span><span class="p">.</span><span class="nx">lastname</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后我们可以在ES6中使用计算属性名。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ES5</span>
<span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="s1">'Robin'</span><span class="p">,</span>
<span class="p">};</span>
<span class="c1">//ES6</span>
<span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s1">'name'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">:</span> <span class="s1">'Robin'</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="单向数据流">单向数据流</h2>

<p>现在我们的组件中有一些内部的state。但是我们还没有操纵它们，因此state是静态的。一个练习state操作好方法是增加一些组件的交互。</p>

<p>让我们为列表中的每一项增加一个按钮。意味着将从列表中删除该项。这个按钮在我们希望保留未读列表和删除不感兴趣的项时会非常有用。</p>

<p>举个中等🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
        <span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">}</span><span class="o">&gt;</span>
          	<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>
            	<span class="p">&lt;</span><span class="nt">a</span> <span class="na">href=</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">url</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">title</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">author</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">num_comments</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">points</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>
            	<span class="p">&lt;</span><span class="nt">button</span> 
                <span class="na">onClick=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">)</span><span class="si">}</span>
                <span class="na">type=</span><span class="s2">"button"</span>
              <span class="p">&gt;</span>
              	Dismiss
              <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="err">/</span><span class="nt">div</span><span class="p">&gt;</span>
        });<span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个类方法onDismiss()还没有被定义，我们稍后再来做这件事。</p>

<p>在<code class="highlighter-rouge">onClick</code>事件处理器中，onDismiss()方法被包裹着。它是一个箭头函数。这样我们可以拿到item对象中的objectID属性来确定哪一项会被删除掉。另一种方法是在<code class="highlighter-rouge">onClick</code>处理器之外定义函数，并只将已定义的函数传到处理器。</p>

<p>我们需要完成onDismiss()的功能，它通过id来标示哪一项需要被删除。此函数绑定到累，因此称为类方法。</p>

<p>这就是为什么我们访问它使用this.onDismiss() 而不是onDismiss()。</p>

<p>this对象是类的实例, 为了将onDismiss() 定义为类方法，我们需要在构造函数中绑定它.</p>

<p>举个有点大的🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">list</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">onDimiss</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
      	<span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">}</span><span class="o">&gt;</span>
          	<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>
            	<span class="p">&lt;</span><span class="nt">a</span> <span class="na">href=</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">url</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">title</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">author</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">num_con</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">num</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>
            	<span class="p">&lt;</span><span class="nt">buttion</span> 
                <span class="na">onClick=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">)</span><span class="si">}</span>
                <span class="na">type=</span><span class="s2">"button"</span>
              <span class="p">&gt;</span>
              onDismiss
              <span class="p">&lt;/</span><span class="nt">buttion</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="err">/</span><span class="nt">div</span><span class="p">&gt;</span>
        });<span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下一步，我们需要在类中定义它的功能和业务逻辑。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">list</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nx">onDismiss</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">....</span>
  <span class="p">}</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在我们可以定义方法内部的功能。总的来说我们希望从列表中删除由id标识的项，并且保存更新后的列表到state中。随后这个更新后列表被使用到再次运行的render()方法中并渲染，最后这个被删除项就不再显示了。</p>

<p>举个中等🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">onDismiss</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">updatedList</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="nx">isNotId</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span> <span class="o">!==</span> <span class="nx">id</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>下一步中，我们可以抽取函数并将其传递给filter函数</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">onDismiss</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">isNotId</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span> <span class="o">!==</span> <span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="kd">const</span> <span class="nx">updatedList</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isNotId</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另外，可以通过使用ES6的箭头函数让代码更简洁。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">onDismiss</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isNotId</span> <span class="o">=</span> <span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span> <span class="o">!==</span> <span class="nx">id</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">updatedList</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isNotId</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>甚至可以内联到一行完成。</p>

<pre><code class="language- react">onDismiss(id) {
  const updatedList = this.state.list.filter(item =&gt; item.objectID !== id);
}
</code></pre>

<p>现在已经从列表中删除了点击项，但是state还没有更新。因此我们需要最后使用类方法<strong>setState();</strong> 来更新组件state中的列表了。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">onDismiss</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">isNotId</span> <span class="o">=</span> <span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span> <span class="o">!==</span> <span class="nx">id</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">updatedList</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isNotId</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span><span class="na">list</span><span class="p">:</span> <span class="nx">updatedList</span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这就是React中的单向数据流。</p>

<p>我们在界面通过onClick触发一个动作，再通过函数或类方法修改组件的state, 最后组件的render() 方法再次运行并更新界面。</p>

<p><img src="/Users/elin/Library/Application Support/typora-user-images/image-20190813231517225.png" alt="image-20190813231517225" /></p>

<h2 id="绑定">绑定</h2>

<p>当使用ES6编写的React组件时，了解JavaScript类的绑定会非常重要。</p>

<p>我们已经在构造函数中绑定了onDismiss() 方法</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">list</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">().</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>绑定的步骤是非常重要的，因为类方法不会自动绑定this到实例上。</p>

<p>我们举个错误的小🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ExplainBindingsComponent</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">onClickMe</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">button</span> 
        <span class="na">onClick=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onClickMe</span><span class="si">}</span>
      	<span class="na">type=</span><span class="s2">"button"</span>
      <span class="p">&gt;</span>
      Click Me
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>组件虽然能正确渲染，但是当我们点击按钮时候，我们会在开发调试控制台中得到undefined。</p>

<p>这是使用React主要的bug来源，因为当我们想在类方法中访问this.state时，由于this是undefined所有并不能被检索到。</p>

<p>所以 为了确保this在类放啊放中是可访问的，我们需要将this绑定到类方法上。</p>

<p>举个正确的🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ExplainBindingsComponent</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">();</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">onClickMe</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">onClickMe</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nx">onClickMe</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">button</span>
        <span class="na">onClick=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onClickMe</span><span class="si">}</span>
        <span class="na">type=</span><span class="s2">"button"</span>
      <span class="p">&gt;</span>
      Click Me
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>再次尝试点击按钮，这个this对象就指向了类的实例。</p>

<p>我们现在就可以访问到this.state了</p>

<p>类方法的绑定也可以写在其他地方，比如写在render()函数中。</p>

<p>🌰举起来</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ExplainBindingsComponent</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">onClickMe</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">button</span>
        <span class="na">onClick=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onClickMe</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="si">}</span>
        <span class="na">type=</span><span class="s2">"button"</span>
      <span class="p">&gt;</span>
        Click Me
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是我们<strong>应该避免</strong>这样做，因为它会在每次render()方法执行时绑定类方法。</p>

<p>总结来说组件每次运行更新时都会导致<strong>性能消耗</strong>。</p>

<p>当在构造函数中绑定时，<strong>绑定只会在组件实例化时运行一次</strong>，这样做是一个更好的方式。</p>

<p>举个🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ExplainBindingsComponent</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">();</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">onClickMe</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">button</span>
        <span class="na">onClick=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onClickMe</span><span class="si">}</span>
        <span class="na">type=</span><span class="s2">"button"</span>
      <span class="p">&gt;</span>
      	Click Me
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们同样也应该<strong>避免这种写法</strong>；因为随着时间的推移它会让我们的构造函数变得混乱。</p>

<p><strong>构造函数的目的</strong>只是实例化你的类以及所有的属性</p>

<p>这就是为什么我们应该把业务逻辑应该定义在构造函数之外。</p>

<p>正确姿势举🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ExplainBindingsComponent</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">();</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">doSomething</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">doSomething</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">doSomethingElse</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">doSomethingElse</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">....</span>
  <span class="p">}</span>
  
  <span class="nx">doSomethingElse</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">....</span>
  <span class="p">}</span>
  
  <span class="p">...</span>
<span class="p">}</span>

</code></pre></div></div>

<p>最后提一下，类方法可以通过ES6的箭头函数做到自动地绑定</p>

<p>举个🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ExplainBindingsComponent</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">onClickMe</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">button</span>
        <span class="na">onClick=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onClickMe</span><span class="si">}</span>
        <span class="na">type=</span><span class="s2">"button"</span>
      <span class="p">&gt;</span>
      	Click Me
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如果在构造函数中的重复绑定对我们有所 困扰，我们可以使用这种方式替代。</p>

<p>React的官方文档中坚持<strong>在构造函数中绑定类方法</strong>。</p>

<h2 id="事件处理">事件处理</h2>

<p>让我们对匀速的事件处理有更深的了解，在我们的应用程序中，我们将使用下面的按钮来从列表中忽略一项内容。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">button</span>
  <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">)}</span>
  <span class="nx">type</span><span class="o">=</span><span class="s2">"button"</span>
<span class="o">&gt;</span>
	<span class="nx">Dismiss</span>
<span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span></code></pre></div></div>

<p>上面已经是一个复杂的例子了，因为我们必须<strong>传递一个参数到类的方法</strong>，因此我们需要将它封装到另一个(箭头)函数中，基本上，由于要传递给事件处理器使用，因此它必须是一个函数。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="o">&lt;</span><span class="nx">button</span> 
  <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">)}</span>
  <span class="nx">type</span><span class="o">=</span><span class="s2">"button"</span>
<span class="o">&gt;</span>
	<span class="nx">Dismiss</span>
<span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="p">...</span>
</code></pre></div></div>

<p>当使用onClick={doSomething()} 时，doSomething()函数会在浏览器打开程序时立即执行，所以点击按钮时不会有任何事发生。</p>

<p>但当使用onClick={doSomething}时，因为doSomething是一个函数，所以它会在点击按钮时执行。</p>

<p>然而，这个类方法如果需要去接收item.objectID属性来识别那个将要被忽略的项。所以这就是为什么它需要被封装到另一个函数中来传递这个属性。</p>

<p>举个🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="o">&lt;</span><span class="nx">button</span>
  <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">)}</span>
  <span class="nx">type</span><span class="o">=</span><span class="s2">"button"</span>
<span class="o">&gt;</span>
	<span class="nx">Dismiss</span>
<span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span><span class="p">...</span>
</code></pre></div></div>

<p>还有一种解决方案是在外部定义一个包装函数，并且只将定义的函数传递给处理程序。因为需要访问特定的列表项，所以它必须位于map函数块的内部</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
      	<span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="kd">const</span> <span class="nx">onHandleDismiss</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectId</span><span class="p">);</span>
          <span class="k">return</span> <span class="p">(</span>
          	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">key=</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="si">}</span><span class="p">&gt;</span>
            	<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>
              	<span class="p">&lt;</span><span class="nt">a</span> <span class="na">href=</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">url</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">title</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
              <span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
              <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">author</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
              <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">num_comments</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
              <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">points</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
              
              <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>
              	<span class="p">&lt;</span><span class="nt">button</span> 
                  <span class="na">onClick=</span><span class="si">{</span><span class="nx">onHandleDismiss</span><span class="si">}</span>
                  <span class="na">type=</span><span class="s2">"button"</span>
                <span class="p">&gt;</span>
                	Dismiss
                <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
              <span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
          <span class="p">);</span>
        <span class="p">})</span><span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>毕竟，传给元素事件处理器的内容必须是函数。</p>

<p>举个🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
      	<span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">&lt;</span><span class="nx">span</span><span class="o">&gt;</span>
          	<span class="p">&lt;</span><span class="nt">button</span> 
              <span class="na">onClick=</span><span class="si">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">)</span><span class="si">}</span>
              <span class="na">type=</span><span class="s2">"button"</span>
            <span class="p">&gt;</span>
            	Dismiss
            <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="err">/</span><span class="nt">span</span><span class="p">&gt;</span>
        })<span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>它会在浏览器加载该程序时执行，但点击按钮时不会被触发。明显和我们规划的不符。</p>

<p>所以，正确姿势举🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">button</span>
  <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">);</span>
  <span class="p">}}</span>
  <span class="nx">type</span><span class="o">=</span><span class="s2">"button"</span>
<span class="o">&gt;</span>
	<span class="nx">Dismiss</span>
<span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span></code></pre></div></div>

<p>换成箭头函数，保持简洁</p>

<p>换个姿势举🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">button</span>
  <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">)}</span>
  <span class="nx">type</span><span class="o">=</span><span class="s2">"button"</span>
<span class="o">&gt;</span>
	<span class="nx">Click</span> <span class="nx">Me</span>
<span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span></code></pre></div></div>

<p>另一个经常会被提到的性能相关话题是在事件处理程序中使用箭头函数的影响。</p>

<p>假设我们有一个包含1000个项目的巨大数据表，每一行或者列在事件处理程序中都有这样一个箭头函数，这个时候就<strong>需要考虑性能影响</strong>，因此我们可以实现一个专用的按钮组件来在构造函数中绑定方法，但这是一个不成熟的优化。</p>

<h2 id="和表单交互">和表单交互</h2>

<p>让我们在程序中加入表单来体验React和表单事件的交互，我们将在程序中加入搜索功能，列表会根据输入框的内容对标题进行过滤。</p>

<p>第一步，我们需要在JSX中定义一个带有输入框的表单。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span><span class="p">(</span>
  	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
    	<span class="p">&lt;</span><span class="nt">form</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type=</span><span class="s2">"text"</span><span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="p">....</span>
      <span class="p">})</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在下面的场景中，将会使用在输入框中的内容作为搜索字段来临时过滤列表。</p>

<p>为了能根据输入框的值过滤列表，我们需要将输入框的值存储在我们的本地状态中，</p>

<p>我们可以使用React的合成事件来访问事件返回值。</p>

<p>让我们为输入框定一个onChange处理程序</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span><span class="p">{</span>
  <span class="p">...</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
      	<span class="p">&lt;</span><span class="nt">form</span><span class="p">&gt;</span>
        	<span class="p">&lt;</span><span class="nt">input</span>
            <span class="na">type=</span><span class="s2">"text"</span>
            <span class="na">onChange=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onSearchChange</span><span class="si">}</span>
          <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
        ...
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个函数被绑定到组件上，因此再次称为一个类方法，我们需要定义方法并bind它</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">list</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">onSearchChange</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">onSearchChange</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="nx">onSearchChange</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>event对象的target属性中带有输入框的值，因此我们可以使用this.setState()来更新本地的搜索词的状态了。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="nx">onSearchChange</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span><span class="na">searchTerm</span><span class="p">:</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">});</span>
  <span class="p">}</span>
	<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>此外，我们应该记住在构造函数中为searchTerm定义初始状态，输入框在开始时应该是空的，因此初始值应该是空字符串。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">list</span><span class="p">,</span>
      <span class="na">searchTerm</span><span class="p">:</span> <span class="s1">''</span><span class="p">,</span>
    <span class="p">};</span>
    
    <span class="k">this</span><span class="p">.</span><span class="nx">onSearchChange</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">onSearchChange</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>关于在React组件中更新状态的简要说明。</p>

<p>React的this.setState() 是一个浅合并，在更新一个唯一的属性时，他会保留状态对象中的其他属性，因此即使我们已经在列表中排除了一个项，在更新searchTerm属性时也会保持不变。</p>

<p>我们需要更具存储在本地状态中的输入字段进行过滤。</p>

<p>我们可以在render()方法中，在map映射列表之前，插入一个过滤的方法。</p>

<p>这个过滤方法将只会匹配标题属性中有searchTerm内容的列表项。</p>

<p>我们可以使用filter+map的方式</p>

<p>举个🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
      	<span class="p">&lt;</span><span class="nt">form</span><span class="p">&gt;</span>
        	<span class="p">&lt;</span><span class="nt">input</span>
            <span class="na">type=</span><span class="s2">"text"</span>
            <span class="na">onChange=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onSearchChange</span><span class="si">}</span>
          <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
        <span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">filter</span><span class="p">(..).</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="p">...</span>
        <span class="p">})</span><span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>另一种方式(高阶函数):</p>

<p>举起巨大的🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">isSearched</span><span class="p">(</span><span class="nx">searchTerm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//.... return true or false</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>该函数接受searchTerm并返回另一个函数，因为所有的filter函数都接受一个函数作为它的输入，返回的函数可以访问列表项目对象，因为它是传给filter函数的函数。</p>

<p>返回的函数将会根据函数中定义的条件对列表进行过滤。</p>

<p>举个🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">isSearched</span><span class="p">(</span><span class="nx">searchTerm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">title</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">().</span><span class="nx">includes</span><span class="p">(</span><span class="nx">searchTerm</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>只有满足匹配时才会返回true并将项目保留在列表中。当不匹配时，项目会从列表中移除。（注意大小写问题）</p>

<p>由于我们使用的是一个不可变的列表，并使用filter函数返回一个新列表，所以本地状态中的原始列表根本就<strong>没有被修改过</strong></p>

<p>JavaScript内置的includes功能，它已经是一个ES6的特性了。</p>

<p>在ES5中我们将使用indexOf()函数来获取列表中项的索引，当项目在列表中时，indexOf()将会返回它的索引。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ES5</span>
<span class="nx">string</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)</span> <span class="o">!==</span> <span class="o">-</span><span class="mi">1</span>
<span class="c1">//ES6</span>
<span class="nx">string</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">pattern</span><span class="p">);</span>
</code></pre></div></div>

<p>上面代码优化后：</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ES5</span>
<span class="kd">function</span> <span class="nx">isSearched</span><span class="p">(</span><span class="nx">searchTerm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">title</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">().</span><span class="nx">includes</span><span class="p">(</span><span class="nx">searchTerm</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//ES6</span>
<span class="kd">const</span> <span class="nx">isSearched</span> <span class="o">=</span> <span class="nx">searchTerm</span> <span class="o">=&gt;</span> <span class="nx">item</span> <span class="o">=&gt;</span> 
<span class="p">{</span><span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">title</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">().</span><span class="nx">includes</span><span class="p">(</span><span class="nx">searchTerm</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">());}</span>
</code></pre></div></div>

<p>我们从本地状态中传递searchTerm属性返回一个根据条件过滤列表的输入过滤函数。之后它会映射过滤后的列表用于显示每个列表项的元素。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">form</span><span class="p">&gt;</span>
        	<span class="p">&lt;</span><span class="nt">input</span> 
            <span class="na">type=</span><span class="s2">"text"</span>
            <span class="na">onChange=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onSearchChange</span><span class="si">}</span>
          <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
        <span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">list</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isSearched</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">searchTerm</span><span class="p">)).</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="p">...</span>
        <span class="p">})</span><span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="受控组件">受控组件</h2>

<p>一个HTML输入标签带有一个value属性，这个属性通常有一个作为输入框的显示。</p>

<p>表单元素比如&lt;input&gt;,&lt;textarea&gt;和&lt;select&gt;会以原生HTML的形式保存它们自己的状态。</p>

<p>一旦有人从外部做了一些修改，它们就会修改内部的值，在React中这被称为<strong>不受控组件</strong>，因为它们自己处理状态。</p>

<p>在React中，我们应该确保这些元素变为<strong>受控组件</strong>。</p>

<p>举个🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">searchTerm</span><span class="p">,</span> <span class="nx">list</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
      	<span class="p">&lt;</span><span class="nt">form</span><span class="p">&gt;</span>
        	<span class="p">&lt;</span><span class="nt">intpu</span> 
            <span class="na">type=</span><span class="s2">"text"</span> 
            <span class="na">onChange=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onSearchChange</span><span class="si">}</span>
            <span class="na">value=</span><span class="si">{</span><span class="nx">searchTerm</span><span class="si">}</span>
            <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
        ...
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>就是这样。现在输入框的单项数据流循环是自包含的，组件内部状态是输入框的唯一数据来源。</p>

<h2 id="拆分组件">拆分组件</h2>

<p>现在，我们有一个大型的App组件。它在不停地扩展，最终可能会变得混乱。我们可以开始将它拆分成若干个更小的组件。</p>

<p>让我们开始使用一个用于搜索的输入组件和一个用于展示的列表组件吧～～。</p>

<p>🌰来了。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">searchTerm</span><span class="p">,</span> <span class="nx">list</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
      	<span class="p">&lt;</span><span class="nc">Search</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Table</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们可以给组件传递属性并在组件中使用它们。至于APP组件，它需要传递由本地状态(state)托管的属性和它自己的类方法。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span><span class="nx">searchTerm</span><span class="p">,</span> <span class="nx">list</span><span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
      	<span class="p">&lt;</span><span class="nc">Search</span>
          <span class="na">value=</span><span class="si">{</span><span class="nx">searchTerm</span><span class="si">}</span>
          <span class="na">onChange=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onSearchChange</span><span class="si">}</span>
        <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Table</span> 
          <span class="na">list=</span><span class="si">{</span><span class="nx">list</span><span class="si">}</span>
          <span class="na">pattern=</span><span class="si">{</span><span class="nx">searchTerm</span><span class="si">}</span>
          <span class="na">onDismiss=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="si">}</span>
          <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在我们可以接着App组件定义这些组件。这些组件仍然是ES6类组件，它们会渲染和之前相同的元素。</p>

<p>第一个是Search组件</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Search</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">onChange</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">form</span><span class="p">&gt;</span>
      	<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type=</span><span class="s2">"text"</span> <span class="na">value=</span><span class="si">{</span><span class="nx">value</span><span class="si">}</span> <span class="na">onChange=</span><span class="si">{</span><span class="nx">onChange</span><span class="si">}</span><span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>第二个是Table组件。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Table</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span><span class="nx">list</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">,</span> <span class="nx">onDismiss</span><span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      	<span class="si">{</span><span class="nx">list</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">isSerched</span><span class="p">(</span><span class="nx">pattern</span><span class="p">)).</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectId</span><span class="p">}</span><span class="o">&gt;</span>
          	<span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>
            	<span class="p">&lt;</span><span class="nt">a</span> <span class="na">href=</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">url</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">title</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">author</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">num_comments</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">item</span><span class="p">.</span><span class="nx">pointer</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;</span>
            	<span class="p">&lt;</span><span class="nt">button</span>
                <span class="na">onClick=</span><span class="si">{</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">onDismiss</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">objectID</span><span class="p">)</span><span class="si">}</span>
                <span class="na">type=</span><span class="s2">"button"</span>
                <span class="p">&gt;</span>
              	Dismiss
              <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="err">/</span><span class="nt">div</span><span class="p">&gt;</span>
        })<span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在我们有了三个ES6类组件。props是properties的简写，当我们在App组件里面使用它时，它有我们传递给这个组件的所有值。这样，组件可以沿着组件树向下传递属性。</p>

<p>从App组件中提取这些组件之后，我们就可以在别的地方去重用它们了。</p>

<h2 id="可组合组件">可组合组件</h2>

<p>在props 对象中还有一个小小的属性可供使用<strong>:children</strong> 属性。通过它我们可以将元素从上层传递到我们的组件中，这些元素对我们的组件来说是未知的，但是却为组件相互组合提供了可能性。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">App</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span><span class="nx">searcgTerm</span><span class="p">,</span> <span class="nx">list</span><span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className=</span><span class="s2">"App"</span><span class="p">&gt;</span>
      	<span class="p">&lt;</span><span class="nc">Search</span> 
          <span class="na">value=</span><span class="si">{</span><span class="nx">searchTerm</span><span class="si">}</span>
          <span class="na">onChange=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onSearchChange</span><span class="si">}</span>
          <span class="p">&gt;</span>
        Search
        <span class="p">&lt;/</span><span class="nc">Search</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Table</span>
          <span class="na">list=</span><span class="si">{</span><span class="nx">list</span><span class="si">}</span>
          <span class="na">pattern=</span><span class="si">{</span><span class="nx">searchTerm</span><span class="si">}</span>
          <span class="na">onDismiss=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">onDismiss</span><span class="si">}</span>
          <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在Search组件可以从props对象中解构出children属性。</p>

<p>然后它就可以指定这个children应该显示在哪里。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Search</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">onChange</span><span class="p">,</span> <span class="nx">children</span> <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">form</span><span class="p">&gt;</span>
      	<span class="si">{</span><span class="nx">children</span><span class="si">}</span> <span class="p">&lt;</span><span class="nt">input</span> 
           <span class="na">type=</span><span class="s2">"text"</span> 
           <span class="na">value=</span><span class="si">{</span><span class="nx">value</span><span class="si">}</span> 
           <span class="na">onChange=</span><span class="si">{</span><span class="nx">onChange</span><span class="si">}</span>
        <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>现在，我们应该可以在输入框旁边看到这个”Search”文本了。</p>

<p><strong>它不仅可以把文本作为子元素传递，还可以将一个元素或者元素树(它还可以再次封装成组件) 作为子元素传递。</strong></p>

<h2 id="可复用组件">可复用组件</h2>

<p>可复用和可组合组件让我们能够思考合理的组件分层，它们是React视图的基础。</p>

<p>现在我们可以复用Search和Table组件了。甚至App组件都是可复用的了，因为我们可以在别的地方重新实例化它。</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Button</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span>
      <span class="nx">onClick</span><span class="p">,</span>
      <span class="nx">className</span><span class="p">,</span>
      <span class="nx">children</span><span class="p">,</span>
    <span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="p">(</span>
    	<span class="p">&lt;</span><span class="nt">button</span>
        <span class="na">onClick=</span><span class="si">{</span><span class="nx">onClick</span><span class="si">}</span>
        <span class="na">className=</span><span class="si">{</span><span class="nx">className</span><span class="si">}</span>
        <span class="na">type=</span><span class="s2">"button"</span>
        <span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">children</span><span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Button组件拥有单一可信数据源。一个Button组件可以立即重构所有button.一个Button统治所有的button</p>

<ul>
  <li>函数式无状态组件：这类组件就是函数，它们接收一个输入并返回一个输出。输入是props,输出就是一个普通的JSX组件实例。然而，函数式无状态组件是函数(函数式的), 并且它们没有本地状态(无状态的)。我们不能通过this.state或者this.setState()来访问或者更新状态，因为这里没有this对象。此外，它也没有生命周期方法。</li>
  <li>ES6类组件：在你的四个组件中，我们已经使用过这类组件了。在类的定义中，它们继承自React组件。extend会注册所有的生命周期方法，只要在React component API中，都可以在你的组件中使用。通过使用this.state和this.setState().我们可以在ES6类组件中储存和操控state。</li>
</ul>

<p><strong>什么时候更适合使用函数式无状态组件呢？</strong></p>

<p>当我们不需要本地状态或者组件生命周期方法时，我们就应该使用函数式无状态组件。最开始一般使用函数式无状态组件来实现我们的组件，一旦我们需要访问state或者生命周期方法时。我们就必须要将它重构成一个ES6类组件。</p>

<p>举一个<strong>ES6转函数式无状态组件</strong>的巨大的🌰</p>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Search</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">onChange</span><span class="p">,</span> <span class="nx">children</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">props</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">form</span><span class="p">&gt;</span>
    	<span class="si">{</span><span class="nx">children</span><span class="si">}</span> <span class="p">&lt;</span><span class="nt">input</span> 
                   <span class="na">type=</span><span class="s2">"text"</span>
                   <span class="na">value=</span><span class="si">{</span><span class="nx">value</span><span class="si">}</span>
                   <span class="na">onChange=</span><span class="si">{</span><span class="nx">onChange</span><span class="si">}</span>
                   <span class="p">/&gt;</span>
    <span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-react highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Search</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">onChange</span><span class="p">,</span> <span class="nx">children</span> <span class="p">})</span> <span class="o">=&gt;</span> 
<span class="p">&lt;</span><span class="nt">form</span><span class="p">&gt;</span>
	<span class="si">{</span><span class="nx">children</span><span class="si">}</span> <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type=</span><span class="s2">"text"</span> <span class="na">value=</span><span class="si">{</span><span class="nx">value</span><span class="si">}</span> <span class="na">onChange=</span><span class="si">{</span><span class="nx">onChange</span><span class="si">}</span><span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div></div>

<h2 id="给组件声明样式">给组件声明样式</h2>

<p>我们可以复用src/App.css和src/index.css文件。因为我们是用create-react-app来创建的，所以这些文件应该已经在我们的项目中了。它们应该也被引入到我们的src/App.js和src/index.js文件中了。</p>

<h2 id="总结回顾">总结回顾</h2>

<ul>
  <li>React
    <ul>
      <li>使用this.state和setState()来管理我们的内部组件状态</li>
      <li>将函数或者类方法传递到我们的元素处理器</li>
      <li>在React中使用表单或者事件来添加交互</li>
      <li>在React中单向数据流是一个非常重要的概念</li>
      <li>拥抱controlled components</li>
      <li>通过children 和可复用组件来组合组件</li>
      <li>ES6类组件和函数式无状态组件的使用方法和实现</li>
      <li>给你的组件声明样式的方式</li>
    </ul>
  </li>
  <li>ES6
    <ul>
      <li>绑定到一个类的函数叫作类方法</li>
      <li>解构对象和数组</li>
      <li>默认参数</li>
    </ul>
  </li>
  <li>General
    <ul>
      <li>高阶函数</li>
    </ul>
  </li>
</ul>

  <!-- 引入share模块 -->
  
  <div class="social-share-wrapper">
    <div class="social-share"></div>
  </div>


<!-- share.js -->
<script src="/assets/js/social-share.min.js"></script>
<script>
  socialShare('.social-share', {
    sites: [
      
        'qq'
        ,
        
      
        'wechat'
        ,
        
      
        'weibo'
        ,
        
      
        'twitter'
        ,
        
      
        'facebook'
        
      
    ],
    wechatQrcodeTitle: "分享到微信朋友圈",
    wechatQrcodeHelper: '期待在朋友圈见到这篇文章'
  });
</script>

</div>

<!-- 底部锚点 -->
<a id="htmldown" name="htmldown"></a>
<!-- 引入评论模块 -->



    <section class="post-footer-item comment">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNDI2OS8xMDgwNg=="></div>
    </section>

    <!-- 来必力City版安装代码 -->
    <script type="text/javascript">
       (function(d, s) {
           var j, e = d.getElementsByTagName(s)[0];

           if (typeof LivereTower === 'function') { return; }

           j = d.createElement(s);
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;

           e.parentNode.insertBefore(j, e);
       })(document, 'script');
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    <!-- City版安装代码已完成 -->





<!-- 引入goto模块 -->
<div class="bounceInRight animated go">
  <a title="顶部切换页面" class="gototop" href="#htmlup" target="_self">
    <div class="box" style="font-family:'ffad_matroregular';">
        Top
    </div>
  </a>
  <a title="底部有livere评论哦" class="gotobottom" href="#htmldown" target="_self">
    <div class="box" style="font-family:'ffad_matroregular';">
        Foot
    </div>
  </a>
</div>

<!-- 引入页面底部模块 -->
<footer id="bottom">
  <br>
  <span>Elin159 ©
  
  
    2018
    -
  
  2020
  <br>
  Powered by <a href="https://www.jekyll.com.cn/">Jekyll</a> | <a href="https://github.com/Elin159/HardCandy-Jekyll">Elin159</a>
  <br>
  粤ICP备19068010号-1
  </span>
</footer>


<!-- 引用wow.js的动画效果 -->
<script src="/assets/js/wow.js"></script>
<script>
    var wow = new WOW({
        boxClass: 'wow',
        animateClass: 'animated',
        // offset: 600,
        mobile: true,
        live: true
    });
    wow.init();
</script>
<!-- 页面刷新回到顶部 -->
<script>
    window.onbeforeunload = function(){
        //刷新后页面自动回到顶部
        document.documentElement.scrollTop = 0;  //ie下
        document.body.scrollTop = 0;  //非ie
    }
</script>
<script src="/assets/js/main.js"></script>
</body>
</html>
